package bck

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

type Repository struct {
	Name string `json:"name"`
}

func getGitHubRepositories(githubToken, accountType, accountName string) ([]string, error) {
	var url string
	if accountType == "user" {
		url = "https://api.github.com/user/repos"
	} else if accountType == "org" {
		url = fmt.Sprintf("https://api.github.com/orgs/%s/repos", accountName)
	} else {
		return nil, fmt.Errorf("invalid account type: must be 'user' or 'org'")
	}

	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	// Set authentication and headers
	req.Header.Set("Authorization", "token "+githubToken)
	req.Header.Set("Accept", "application/vnd.github.v3+json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("GitHub API request failed: %s", body)
	}

	// Parse JSON response
	var repos []Repository
	err = json.NewDecoder(resp.Body).Decode(&repos)
	if err != nil {
		return nil, err
	}

	// Extract repository names
	var repoNames []string
	for _, repo := range repos {
		repoNames = append(repoNames, repo.Name)
	}

	return repoNames, nil
}

func main() {
	githubToken := os.Getenv("GITHUB_TOKEN") // Store token securely as an environment variable
	accountType := "user"                    // Change to "org" if listing org repositories
	accountName := "jcotoBan"                // Only needed for organizations

	repositories, err := getGitHubRepositories(githubToken, accountType, accountName)
	if err != nil {
		fmt.Println("Error fetching repositories:", err)
		return
	}

	apiToken := "5f8cadf0-508b-476a-b7c3-09125dfca4ca"
	integrationID := "3604"
	sysdigURL := "https://app.us4.sysdig.com/api/cspm/v1/gitProvider/gitSources"

	client := &http.Client{}

	for _, repo := range repositories {
		data := map[string]interface{}{
			"source": map[string]interface{}{
				"repository":          repo,
				"folders":             []string{"/"},
				"prScanBranchPattern": "main",
				"integrationId":       integrationID,
				"name":                fmt.Sprintf("%s_source", repo),
			},
		}

		jsonData, err := json.Marshal(data)
		if err != nil {
			fmt.Printf("Failed to marshal JSON for %s: %v\n", repo, err)
			continue
		}

		req, err := http.NewRequest("POST", sysdigURL, bytes.NewBuffer(jsonData))
		if err != nil {
			fmt.Printf("Failed to create request for %s: %v\n", repo, err)
			continue
		}

		req.Header.Set("Authorization", "Bearer "+apiToken)
		req.Header.Set("Content-Type", "application/json")

		resp, err := client.Do(req)
		if err != nil {
			fmt.Printf("Request failed for %s: %v\n", repo, err)
			continue
		}
		defer resp.Body.Close()

		body, _ := ioutil.ReadAll(resp.Body)
		if resp.StatusCode == http.StatusOK {
			fmt.Printf("Successfully added %s\n", repo)
		} else {
			fmt.Printf("Failed to add %s: %s\n", repo, body)
		}
	}

}
